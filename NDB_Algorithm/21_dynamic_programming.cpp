/*
	Dynamic Programming(동적 계획법)
	하나의 문제는 단 한번만 풀도록 하는 알고리즘 

	한 번 푼 문제는 다시 풀지 않고,
	그 값을 저장해서 다시 그 값을 요구할 때 이미 구한 값을 제시

	상당수 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있음
	(대표적으로 피보나치 수열)

	일반적으로 단순 분할정복으로 풀게 되면 심각한 비효율성을 낳는 경우가 많다.


	DP는 다음 가정하에 사용할 수 있다.

	1. 큰 문제를 작은 문제로 나눌 수 있다.
	2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

	이 과정에서 "메모이제이션(memoization)"이 사용된다는 점에서 분할 정복과 다르다
	이미 계산한 결과는 배열에 저장함으로써 나중에 동일한 계산을 해야 할 때에는 
	지정된 값을 단순히 반환하기만 하면 됨

*/

//피보나치 수열

#include <stdio.h>

int memo[100] = { 0, };//배열을 전역변수로 정의해주면, 배열의 모든 원소가 0으로 초기화 됨

int dp(int x) {
	if (x == 1 || x == 2) return 1;
	if (memo[x] != 0) return memo[x];
	return memo[x] = dp(x - 1) + dp(x - 2);
}

int main(){
	printf("%d \n", dp(30)); //n=50이면 2^50만큼 연산 필요
}
