/*
	오름차순 정렬 시
	삽입 정렬은 각 숫자를 "적절한 위치"에 삽입하는 방법으로 문제해결
	다른 정렬방식은 무조건 위치를 바꿨지만, 삽입정렬은 '필요할 때만' 위치를 바꾼다.
	=> 즉 선택과 버블 정렬같은 경우는 , 이미 정렬된 상태더라도, 무조건 반복을 수행함
	=> 삽입정렬은 필요할때만 위치를 바꿈
	=> 이런한 특성때문에 선택과 버블정렬보다 더 빠르다.
	=> 특정한 경우에는 굉장히 빠르게 동작
	=> 삽입정렬은 시간복잡도 O(N^2)을 가지는 정렬방식중 가장 빠르게 동작

	삽입정렬의 경우, 앞에 있는 원소들이 이미 '정렬'이 되어있다고 '가정'함
	이렇게 '가정'하기 때문에, 버블 선택 정렬보다 더 빠르게 동작

	최악의 경우에는 버블 정렬 선택정렬과 같이 복잡도가 나오지만,
	거의 정렬된 경우! 굉장히 빠르게 연산이 처리된다.
	거의 정렬된 상태에서는 삽입정렬이 굉장이 효율적

*/
#include <stdio.h>

/*
int main() {
	int arr[10] = { 3,1,4,1,5,9,2,4,7,16 };
	int temp;

	for (int i = 0; i < 10; i++) {
		for (int j = i; j > 0; j--) {
			if (arr[j] < arr[j - 1]) {
				temp = arr[j - 1];
				arr[j - 1] = arr[j];
				arr[j] = temp;
			}
			else break;
		}
	}
	for (int i = 0; i < 10; i++) {
		printf("%d ", arr[i]);
	}
	puts("");
	return 0;
}
*/

int main() {
	int arr[10] = { 3,1,4,1,5,9,2,4,7,19 };
	//int j;
	int temp;

	for (int i = 0,j; i < 9; i++) {
		j = i;
		while (arr[j] > arr[j + 1]) {
			temp = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = temp;
			j--;
		}
	}
	for (int i = 0; i < 10; i++) {
		printf("%d ", arr[i]);
	}
	puts("");
	return 0;
}