/*
	오름차순 정렬시
	버블 정렬 : 바로 가까이에 있는 두 숫자끼리 비교해서 당장 더 작은 숫자를 앞으로 보내주는 것을 반복하는 것

	직관적이고 쉽게 생각할 수 있고, 쉽게 구현가능한 알고리즘
	구현하기는 가장 쉬우나, 효율성은 가장 떨어진다.

	한번의 반복이 끝났을때 가장 큰 값이 맨뒤로 보내지는 결과가 나온다.

	10 + 9 + 8 + ... + 1
	=> O(N^2) // 선택정렬과 시간복잡도 같음
	=> 실제로 작동시키면, 선택정렬보다 더 느리게 작동함
	=> 비교시마다 3개의 명령으로 이루어진 SWAP연산을 실행하기 때문
	=> 선택정렬은 가장 작은 것 하나 골라서 마지막에 교환해주지만
		버블정렬은 매번 교환해줘야함

*/


#include <stdio.h>

int main() {
	int arr[10] = { 3,1,4,1,5,9,2,6,9,7 };
	int temp = 0;

	for (int i = 9; i > 0; i--) {
		for (int j = 0; j < i; j++) {
			if (arr[j] > arr[j + 1]) {
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	for (int i = 0; i < 10; i++) {
		printf("%d ", arr[i]);
	}
	puts("");
	return 0;
}